
# coding: utf-8

# In[1]:

'''
This is the module integerSmithNormalFormAndApplications. 

For a matrix $A$ with dimesion $(m,n)$ and entries in $\mathbb Z$ the function `integerSmithNormalForm` computes a pair of regular 
squared matrices $R$ ($m x m$) and $C$ ($n x n$) with entries in $\mathbb Z$.

This function is used in the following functions:

- `equationsToGeneratorsHomogeneusCase`: if $5x-7y+3z-2t=0$ and $6x+9y-10z+t=0$ are the defining equations of a subgroup $M$ of $\mathbb Z^4$, the command `equationsToGeneratorsHomogeneusCase(Matrix([[5,-7,3,-2],[6,9,-10,1]]))` returns a matrix whose rows form a minimal system of generator of the subgroup $M$.
- `equationsToGenerators`: if $x-2y+3z+4t=0\mod 2$, $6x+8y-10z-16t=0\mod 3$ and $5x+7y-9z+2t=0$ and the defining equations of a subgroup $M$ of $\mathbb Z^4$, the command `equationsToGenerators(Matrix([[1,-2,3,4],[6,8,-10,-16],[5,7,-9,2]]),Matrix([2,3]))` returns a matrix whose rows form a minimal system of generators of $M$.
- `minimalSystemOfGenerators`: if $M$ is the subgroup of $\mathbb Z^3$ generated by $\{(5,1,0),(1,2,-3),(6,3,-3)\}$, the command `minimalSystemOfGenerators(Matrix([[5,1,0],[1,2,-3],[6,3,-3]]))` returns a minimal system of generators of $M$.
- `generatorsToEquations`: if $M$ is generated by the elements of $\{(2,-4,8),(3,2,-1)\}$, the commands 
`generatorsToEquations(Matrix([[2,-4,8],[3,2,-1]])[x,y,z])`and 
`generatorsToEquations(Matrix([[2,-4,8],[3,2,-1]]))` returns a set of defining equations of $M$.

To get examples just type:
* help(sympyMatrix2numpyArray),
* help(numpyArray2sympyMatrix),
* help(lcmL),
* help(gcdL),
* help(integerSmithNormalForm),
* help(equationsToGeneratorsHomogeneusCase),
* help(equationsToGenerators),
* help(minimalSystemOfGenerators),
* help(generatorsToEquations),
'''
pass


# # Integer Smith normal form and applications.
# For a matrix $A$ with dimesion $(m,n)$ and entries in $\mathbb Z$ the function `integerSmithNormalForm` computes a pair of regular squared matrices $R$ ($m\times m$) and $C$ ($n\times n$) with entries in $\mathbb Z$.
# 
# This function is used to obtain the following functions:
# 
# - `equationsToGeneratorsHomogeneusCase`: if $5x-7y+3z-2t=0$ and $6x+9y-10z+t=0$ are the defining equations of a subgroup $M$ of $\mathbb Z^4$, the command `equationsToGeneratorsHomogeneusCase(Matrix([[5,-7,3,-2],[6,9,-10,1]]))` returns a matrix whose rows form a minimal system of generator of the subgroup $M$.
# - `equationsToGenerators`: if $x-2y+3z+4t=0\mod 2$, $6x+8y-10z-16t=0\mod 3$ and $5x+7y-9z+2t=0$ and the defining equations of a subgroup $M$ of $\mathbb Z^4$, the command `equationsToGenerators(Matrix([[1,-2,3,4],[6,8,-10,-16],[5,7,-9,2]]),Matrix([2,3]))` returns a matrix whose rows form a minimal system of generators of $M$.
# - `minimalSystemOfGenerators`: if $M$ is the subgroup of $\mathbb Z^3$ generated by $\{(5,1,0),(1,2,-3),(6,3,-3)\}$, the command `minimalSystemOfGenerators(Matrix([[5,1,0],[1,2,-3],[6,3,-3]]))` returns a minimal system of generators of $M$.
# - `generatorsToEquations`: if $M$ is generated by the elements of $\{(2,-4,8),(3,2,-1)\}$, the commands 
# `generatorsToEquations(Matrix([[2,-4,8],[3,2,-1]])[x,y,z])`and 
# `generatorsToEquations(Matrix([[2,-4,8],[3,2,-1]]))` returns a set of defining equations of $M$.

# In[33]:

print(__doc__)


# ## We import the libraries used

# In[34]:

import math
from math import gcd
from sympy import Matrix, eye, init_printing, pprint, zeros
import sympy
import itertools
from subprocess import call, PIPE, Popen
import json
from  numpy.random import randint
import numpy
from fractions import Fraction
from sympy import groebner
import numpy as np
from numpy import array

init_printing(use_latex='mathjax')


# Several simple functions, some of them not used. 

# In[89]:

def lcm(a,b): return int(round(abs(a * b) / math.gcd(a,b))) if a and b else 0
def lcmL(l):
    '''
    >>> lcmL([5,12,13])
    '''
    if len(l)==1:
        return l[0]
    if len(l)==2:
        return lcm(l[0],l[1])
    else:
        aux=l[2:]+[lcm(l[0],l[1])]
        return lcmL( aux )

def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    g = b
    return g, x, y

def gcdL(l):
    '''
    >>> gcdL([12,34,22])
    '''
    if len(l)==1:
        return l[0]
    if len(l)==2:
        return gcd(l[0],l[1])
    else:
        aux=l[2:]+[gcd(l[0],l[1])]
        return gcdL(aux)

def gcdMatrix(A):
    return gcdL(A[:])

def sympyMatrix2numpyArray(m,tipo=np.int):
    '''
    >>> sympyMatrix2numpyArray(Matrix([[1,2],[2,3]]))
    '''
    nf,nc=m.shape
    return array(list(m),dtype=tipo).reshape(nf,nc)
def numpyArray2sympyMatrix(npM):
    '''
    >>> numpyArray2sympyMatrix( np.array([[1,2],[3,4]]) )
    '''
    return Matrix( list( map( lambda x:list(map(int,x)) , npM ) ) )


# ## Several functions used to check the returned values of the function `integerSmithNormalForm`.

# In[36]:

def isDiagonal(A):
    nf,nc=A.shape
    for i in range(nf):
        for j in range(nc):
            if i!=j and A[i,j]!=0:
                return False
    return True

def isSeqDiagOfDivisible(A):
    nf,nc=A.shape
    k=min(nf,nc)
    if not isDiagonal(A):
        return False
    for i in range(1,k):
        if A[i,i] % A[i-1,i-1]!=0:
            return False
    return True


# ---
# ## Function `integerSmithNormalForm`

# Some auxilary functions

# In[37]:

def posMinNonNullOfMatrix(A):
    nf,nc=A.shape
    l=A[:]
    m=min([x for x in l if x!=0])
    aux=l.index(m)   
    return (aux//nc,aux%nc)
def putAbsMinInCorner(A):
    nf,nc=A.shape
    R=eye(nf)
    C=eye(nc)
    Aux=Matrix(A)
    i,j=posMinNonNullOfMatrix(Aux.applyfunc(abs))
    R.row_swap(i,0)
    C.col_swap(j,0)
    Aux=R.multiply(Aux).multiply(C)
    if Aux[0,0]<0:
        Raux=eye(nf)
        Raux[0,0]=-1
        R=Raux.multiply(R)
    return (R,C)


# In[38]:

def addRowIfNecesary(A):
    nf,nc=A.shape
    Aux=Matrix(A)
    c=Aux[0,0]
    k=None
    for i in range(1,nf):
        if Aux[i,:].applyfunc(lambda x:x%c)!=Matrix.zeros(1,nc):
            k=i
            break;
    Maux=Matrix.eye(nf)
    if k:
        Maux[0,:]=Maux[0,:]+Maux[k,:]
    return Maux


# In[39]:

def makeZeroInFirstColumn(A,i):
    Aux=Matrix(A)
    nf,nc=Aux.shape
    m1=sympy.eye(nf)
    if Aux[0,0]<0:
        m1[0,:]=-m1[0,:]
    Aux=m1.multiply(Aux)
    if Aux[i,0]==0:
        return m1
    while Aux[i,0]!=0:
        q=Aux[i,0]//Aux[0,0]
        maux=sympy.eye(nf)
        maux[i,:]=maux[i,:]-q*maux[0,:]
        Aux=maux.multiply(Aux)
        m1=maux.multiply(m1)
        if Aux[i,0]!=0:
            maux=eye(nf)
            maux.row_swap(0,i)
            m1=maux.multiply(m1)
            Aux=maux.multiply(Aux)
    return m1

def makeZeroInFirstRow(A,i):
    RT=makeZeroInFirstColumn(A.T,i)
    return RT.T

def makeZeroFirstColumn(A):
    nf,nc=A.shape
    Aux=Matrix(A)
    R=Matrix.eye(nf)
    for i in range(1,nf):
        Raux=makeZeroInFirstColumn(Aux,i)
        Aux=Raux.multiply(Aux)
        R=Raux.multiply(R)
    return R

def makeZeroFirstRow(A):
    B=Matrix(A.T)
    CT=makeZeroFirstColumn(B)
    return CT.T
def makeZerosFirstRowColumn(A):
    Aux=Matrix(A)
    nf,nc=A.shape
    R1=eye(nf)
    C1=eye(nc)
    c0=Aux[1:,0]
    f0=Aux[0,1:]
    while(c0!=zeros(nf-1,1) or f0!=zeros(1,nc-1)):
        #print(c0,' - ',f0)
        #print(Aux)
        R=makeZeroFirstColumn(Aux)
        Aux=R.multiply(Aux)
        R1=R.multiply(R1)
        #print(Aux)
        C=makeZeroFirstRow(Aux)
        Aux=Aux.multiply(C)
        C1=C.multiply(C1)
        #print(Aux)
        #ee=input()
        #if not ee:
        #    break;
        c0=Aux[1:,0]
        f0=Aux[0,1:]
    return (R1,C1)


# The function `integerSmithNormalForm`

# In[90]:

def integerSmithNormalForm(A):
    '''
    >>> A=Matrix([[-3,11,3],[-48,15,12]])
    >>> R,C=integerSmithNormalForm(A)
    >>> [R.multiply(A).multiply(C),R.det(),C.det()]
    '''
    nf,nc=A.shape
    Aux=Matrix(A)
    R=eye(nf)
    C=eye(nc)
    if A==zeros(nf,nc):
        return (R,C)
    else:
        t=True
        while(t):
            R1,C1=putAbsMinInCorner(Aux)
            Aux=R1.multiply(Aux).multiply(C1)
            R=R1.multiply(R)
            C=C.multiply(C1)
            #print('abs in conrner:',Aux)
        
            R1,C1=makeZerosFirstRowColumn(Aux)
            Aux=R1.multiply(Aux).multiply(C1)
            R=R1.multiply(R)
            C=C.multiply(C1)
            #print('zeros in 1st RC:',Aux)

            R1=addRowIfNecesary(Aux)
            Aux=R1.multiply(Aux)
            R=R1.multiply(R)
            #print('add row if nec:',Aux)
            t= not (R1==eye(nf))
            
    Rm,Cm=integerSmithNormalForm(Aux[1:,1:])
    Raux=eye(nf)
    Caux=eye(nc)
    Raux[1:,1:]=Rm
    Caux[1:,1:]=Cm
    return (Raux.multiply(R),C.multiply(Caux))


# Examples of how to use it

# In[58]:

# A=Matrix([[-3,11,3],[-48,15,12]])
# R,C=integerSmithNormalForm(A)
# [R.multiply(A).multiply(C),R.det(),C.det()]


# In[59]:

# A=Matrix([[4],[16]])
# R,C=integerSmithNormalForm(A)
# [R.multiply(A).multiply(C),R.det(),C.det()]


# In[60]:

# A=Matrix([[2,-1,1],[3,2,-1]])
# R,C=integerSmithNormalForm(A)
# [R.multiply(A).multiply(C),R.det(),C.det()]


# In[61]:

# A=Matrix([[2,0,0],[0,1,-1]])
# R,C=integerSmithNormalForm(A)
# [R.multiply(A).multiply(C),R.det(),C.det()]


# In[62]:

# A=Matrix([[4,1,-3],[1,-2,1]])
# R,C=integerSmithNormalForm(A)
# [R.multiply(A).multiply(C),R.det(),C.det()]


# In[63]:

# A=Matrix([[1,-2,2,-1],[-3,1,1,1]])
# R,C=integerSmithNormalForm(A)
# [R.multiply(A).multiply(C),R.det(),C.det()]


# In[64]:

# A=Matrix([[2,1,-2],[2,-1,1]])
# R,C=integerSmithNormalForm(A)
# [R.multiply(A).multiply(C),R.det(),C.det()]


# Aleatory examples

# In[65]:

# A=Matrix(randint(-50,50,(2,3))).applyfunc(int)
# R,C=integerSmithNormalForm(A)
# [R.multiply(A).multiply(C),R.det(),C.det()]


# In[66]:

# A=Matrix([[-3,11,3],[-48,15,12]])
# R,C=integerSmithNormalForm(A)
# [R.multiply(A).multiply(C),R.det(),C.det()]


# In[67]:

# for x in range(10):
#     sh=tuple(map(int,randint(1,7,(1,2))[0]))
#     A=randint(-100,100,sh)
#     l=[list(x) for x in A]
#     A=Matrix(l).applyfunc(int)
#     pprint(A)
#     pprint((A,Matrix(sh).T.applyfunc(int)))
#     R,C=integerSmithNormalForm(A)
#     D=R.multiply(A).multiply(C)
#     pprint([D,R.det(),C.det(),isSeqDiagOfDivisible(D)])
#     print(isDiagonal(D))
#     print(isSeqDiagOfDivisible(D))
#     if not isSeqDiagOfDivisible(D):
#         print(A)


# In[68]:

# A=Matrix([[-31, -96, -63, 81], [32, -31, -5, 33], [9, 70, 48, 57], [85, 61, -67, 86]])
# print(A)
# R,C=integerSmithNormalForm(A)
# [R.multiply(A).multiply(C),R.det(),C.det()]


# ## Function to compute the generators of a subgroup of $\mathbb Z^p$ from its defining equations

# #### Function to obtain a minimal system of generators from a set of homogeneus equations

# In[69]:

def equationsToGeneratorsHomogeneusCase(A):
    '''
    >>> equationsToGeneratorsHomogeneusCase(Matrix([[5,-7,3,-2],[6,9,-10,1]]))
    '''
    nf,nc=A.shape
    R,C=integerSmithNormalForm(A)
    D=R.multiply(A).multiply(C)
    noNullOfD=[D[i,i] for i in range(min(D.shape)) if D[i,i]!=0]
    r=len(noNullOfD)
    nGen=nc-r
    Caux=C[:,-nGen:].T
    return Caux
    #return [Caux[i,:] for i in range(Caux.shape[0])]


# In[70]:

# A=Matrix([[5,7,-3,-2],[1,2,3,4]])
# print(A)
# sG=equationsToGeneratorsHomogeneusCase(A)
# pprint(sG)


# In[71]:

# A.multiply(sG.T)


# #### Function to obtain the minimal system from a set of equations

# In[91]:

def equationsToGenerators(A,modulus):
    '''
    >>> A=Matrix([[1,-2,3,4],[6,8,-10,-16],[5,7,-9,2]])
    >>> mm=Matrix([2,3])
    >>> sG=equationsToGenerators(A,mm)
    >>> pprint(sG)
    >>> A.multiply(sG.T)
    '''
    Aux=Matrix(A)
    nfm,ncm=modulus.shape
    nf,nc=A.shape
    idaux=eye(nfm)
    for i in range(nfm):
        idaux[i,i]=-modulus[i]
    zaux=zeros(nf-nfm,nfm)
    idaux=idaux.col_join(zaux)
    Aux=Aux.row_join(idaux)
    #pprint(Aux)
    r=equationsToGeneratorsHomogeneusCase(Aux)
    #pprint(Aux.multiply(r.T))
    return r[:,0:nc]


# In[92]:

# A=Matrix([[1,-2,3,4],[6,8,-10,-16],[5,7,-9,2]])
# pprint(A)
# mm=Matrix([2,3])
# sG=equationsToGenerators(A,mm)
# pprint(sG)
# A.multiply(sG.T)


# #### Function to compute aminimal system of generators from asystem of generators

# In[93]:

def minimalSystemOfGenerators(sGen):
    '''
    Returns a minimal system of generators of the subgroup generated by 
    the rows of the sympy.matrix sGen.
    >>> minimalSystemOfGenerators(Matrix([[5,1,0],[1,2,-3],[6,3,-3]]))
    '''
    A=Matrix(sGen)
    R,C=integerSmithNormalForm(A)
    D=R.multiply(A).multiply(C)
    RA=R.multiply(A)
    noNullOfD=[D[i,i] for i in range(min(D.shape)) if D[i,i]!=0]
    r=len(noNullOfD)
    return RA[0:r,:]


# In[94]:

# minimalSystemOfGenerators(Matrix([[5,1,0],[1,2,-3],[6,3,-3]]))


# #### Function to compute the equations from a system of generators

# In[95]:

def generatorsToEquations(sGen,lVars=None):
    '''
    >>> sGen=Matrix([[2,-4,8],[3,2,-1]])
    >>> s1=generatorsToEquations(sGen,[x,y,z])
    >>> s2=generatorsToEquations(sGen)
    >>> [s1,s2]
    '''
    A=Matrix(sGen)
    nf,nc=A.shape
    R,C=integerSmithNormalForm(A)
    D=R.multiply(A).multiply(C)
    noNullOfD=[D[i,i] for i in range(min(D.shape)) if D[i,i]!=0]
    lmod=noNullOfD+[0 for i in range(nc-len(noNullOfD))]
    n1=len([x for x in noNullOfD if x==1])
    lmod=lmod[n1:]
    if not lVars:
        return (C.T[n1:,:],Matrix(lmod))
    else:
        return (Matrix(lVars).T.multiply(C[:,n1:]).T,Matrix(lmod))


# In[96]:

# sGen=Matrix([[2,-4,8],[3,2,-1]])
# x,y,z=sympy.symbols('x y z')
# s1=generatorsToEquations(sGen,[x,y,z])
# s2=generatorsToEquations(sGen)
# [s1,s2]


# In[97]:

# A=Matrix([[2,-1,1],[3,2,-1]])
# R,C=integerSmithNormalForm(A)
# [R,R.multiply(A).multiply(C),C]


# ---

# In[98]:

# x1,x2,x3,x4,x5,x6=sympy.symbols('x1 x2 x3 x4 x5 x6')


# $\widetilde H=\mathbf N^4/\sim_M$ with 
# $M=\langle (-5,3,2,10),(-2,1,4,15),(-5,3,2,0) \rangle $

# In[99]:

# genM=Matrix([[-5,-7,5,7],[12,1,-1,-12],[-5,0,0,5]])
# generatorsToEquations(genM,[x1,x2,x3,x4])


# $\widetilde H \cong \langle (8,1),(5,1),(1,1),(0,1)\rangle \leq \mathbf Z_{10}\times \mathbf Z$

# # Examples of _On divisor-closed submonoids and minimal distances in finitely generated monoids_

# ## Example 24

# In[100]:

# genM=Matrix([[-5,-7,5,7],[12,1,-1,-12],[-5,0,0,5]])
# generatorsToEquations(genM,[x1,x2,x3,x4])


# ## Example 25

# In[101]:

# genM=Matrix([[-4,-2,4,4],[5,2,-5,-4],[2,2,-2,-4]])
# generatorsToEquations(genM,[x1,x2,x3,x4])


# $\Delta(H)$ is in this case equal to

# In[102]:

# aux=numpy.abs(numpy.sum(numpy.array([list(genM[i,:]) for i in range(genM.shape[0])]),axis=1))
# aux,numpy.min(aux)


# In[103]:

# AejFin=Matrix([[1,0],[2,1]])
# pprint(AejFin)
# mmEjemploFin=Matrix([2])
# sGejemploFin=equationsToGenerators(AejFin,mmEjemploFin)
# pprint(sGejemploFin)
# AejFin.multiply(sGejemploFin.T)


# ## Example 30

# We compute a system of generators of the group associated to $H$ and $\min(\Delta(H))$

# In[104]:

# m=equationsToGeneratorsHomogeneusCase(Matrix([[5,10,15,0,10],[9,11,5,0,0],[0,0,0,1,1]]))
# pprint(m)
# l=np.sum(sympyMatrix2numpyArray(m),axis=1)
# pprint(l)
# md=gcdL(l)


# $\min(\Delta(H))$ is equal to {{md}}

# We compute now $\min(\Delta(S_6))$

# In[86]:

# m=equationsToGeneratorsHomogeneusCase(Matrix([[5,10,15],[9,11,5],[0,0,0]]))
# pprint(m)
# l=np.sum(sympyMatrix2numpyArray(m),axis=1)
# print(l)
# md=gcdL(l)


# $\min(\Delta(S_6))$ is equal to {{np.abs(md)}}

# ## Example 31

# Group associated to $\pi(S_{22})$

# In[87]:

# equationsToGenerators(Matrix([[1,0],[2,1]]),Matrix([2]))

