
Integer Smith normal form and applications.
===========================================

For a matrix :math:`A` with dimesion <a href="https://www.codecogs.com/eqnedit.php?latex=(m,n)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?(m,n)" title="(m,n)" /></a> and entries in <a href="https://www.codecogs.com/eqnedit.php?latex=\mathbb{N}^p" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mathbb{Z}^p" title="\mathbb{Z}^p" /></a> the function ``integerSmithNormalForm`` computes a
pair of regular squared matrices`R` (<a href="https://www.codecogs.com/eqnedit.php?latex=m\times&space;m" target="_blank"><img src="https://latex.codecogs.com/gif.latex?m\times&space;m" title="m\times m" /></a>) and
:math:`C` (:math:`n\times n`) with entries in :math:`\mathbb Z`.

This function is used to obtain the following functions:

-  ``equationsToGeneratorsHomogeneusCase``: if :math:`5x-7y+3z-2t=0` and
   :math:`6x+9y-10z+t=0` are the defining equations of a subgroup
   :math:`M` of :math:`\mathbb Z^4`, the command
   ``equationsToGeneratorsHomogeneusCase(Matrix([[5,-7,3,-2],[6,9,-10,1]]))``
   returns a matrix whose rows form a minimal system of generator of the
   subgroup :math:`M`.
-  ``equationsToGenerators``: if :math:`x-2y+3z+4t=0\mod 2`,
   :math:`6x+8y-10z-16t=0\mod 3` and :math:`5x+7y-9z+2t=0` and the
   defining equations of a subgroup :math:`M` of :math:`\mathbb Z^4`,
   the command
   ``equationsToGenerators(Matrix([[1,-2,3,4],[6,8,-10,-16],[5,7,-9,2]]),Matrix([2,3]))``
   returns a matrix whose rows form a minimal system of generators of
   :math:`M`.
-  ``minimalSystemOfGenerators``: if :math:`M` is the subgroup of
   :math:`\mathbb Z^3` generated by
   :math:`\{(5,1,0),(1,2,-3),(6,3,-3)\}`, the command
   ``minimalSystemOfGenerators(Matrix([[5,1,0],[1,2,-3],[6,3,-3]]))``
   returns a minimal system of generators of :math:`M`.
-  ``generatorsToEquations``: if :math:`M` is generated by the elements
   of :math:`\{(2,-4,8),(3,2,-1)\}`, the commands
   ``generatorsToEquations(Matrix([[2,-4,8],[3,2,-1]])[x,y,z])``\ and
   ``generatorsToEquations(Matrix([[2,-4,8],[3,2,-1]]))`` returns a set
   of defining equations of :math:`M`.

We import the libraries used

.. code:: python

    import math
    from math import gcd
    from sympy import Matrix, eye, init_printing, pprint, zeros
    import sympy
    import itertools
    from subprocess import call, PIPE, Popen
    import json
    from  numpy.random import randint
    import numpy
    from fractions import Fraction
    from sympy import groebner
    import numpy as np
    from numpy import array
    
    init_printing(use_latex='mathjax')

Several simple functions, some of them not used.

.. code:: python

    def lcm(a,b): return int(round(abs(a * b) / math.gcd(a,b))) if a and b else 0
    def lcmL(l):
        if len(l)==1:
            return l[0]
        if len(l)==2:
            return lcm(l[0],l[1])
        else:
            aux=l[2:]+[lcm(l[0],l[1])]
            return lcmL( aux )
    
    def egcd(a, b):
        x,y, u,v = 0,1, 1,0
        while a != 0:
            q, r = b//a, b%a
            m, n = x-u*q, y-v*q
            b,a, x,y, u,v = a,r, u,v, m,n
        g = b
        return g, x, y
    
    def gcdL(l):
        if len(l)==1:
            return l[0]
        if len(l)==2:
            return gcd(l[0],l[1])
        else:
            aux=l[2:]+[gcd(l[0],l[1])]
            return gcdL(aux)
    
    def gcdMatrix(A):
        return gcdL(A[:])
    
    def sympyMatrix2numpyArray(m,tipo=np.int):
        '''
        '''
        nf,nc=m.shape
        return array(list(m),dtype=tipo).reshape(nf,nc)
    def numpyArray2sympyMatrix(npM):
        return Matrix( list( map( lambda x:list(map(int,x)) , npM ) ) )


Several functions used to check the returned values of the function
``integerSmithNormalForm``.

.. code:: python

    def isDiagonal(A):
        nf,nc=A.shape
        for i in range(nf):
            for j in range(nc):
                if i!=j and A[i,j]!=0:
                    return False
        return True
    
    def isSeqDiagOfDivisible(A):
        nf,nc=A.shape
        k=min(nf,nc)
        if not isDiagonal(A):
            return False
        for i in range(1,k):
            if A[i,i] % A[i-1,i-1]!=0:
                return False
        return True

--------------

Function ``integerSmithNormalForm``
-----------------------------------

Some auxilary functions

.. code:: python

    def posMinNonNullOfMatrix(A):
        nf,nc=A.shape
        l=A[:]
        m=min([x for x in l if x!=0])
        aux=l.index(m)   
        return (aux//nc,aux%nc)
    def putAbsMinInCorner(A):
        nf,nc=A.shape
        R=eye(nf)
        C=eye(nc)
        Aux=Matrix(A)
        i,j=posMinNonNullOfMatrix(Aux.applyfunc(abs))
        R.row_swap(i,0)
        C.col_swap(j,0)
        Aux=R.multiply(Aux).multiply(C)
        if Aux[0,0]<0:
            Raux=eye(nf)
            Raux[0,0]=-1
            R=Raux.multiply(R)
        return (R,C)

.. code:: python

    def addRowIfNecesary(A):
        nf,nc=A.shape
        Aux=Matrix(A)
        c=Aux[0,0]
        k=None
        for i in range(1,nf):
            if Aux[i,:].applyfunc(lambda x:x%c)!=Matrix.zeros(1,nc):
                k=i
                break;
        Maux=Matrix.eye(nf)
        if k:
            Maux[0,:]=Maux[0,:]+Maux[k,:]
        return Maux

.. code:: python

    def makeZeroInFirstColumn(A,i):
        Aux=Matrix(A)
        nf,nc=Aux.shape
        m1=sympy.eye(nf)
        if Aux[0,0]<0:
            m1[0,:]=-m1[0,:]
        Aux=m1.multiply(Aux)
        if Aux[i,0]==0:
            return m1
        while Aux[i,0]!=0:
            q=Aux[i,0]//Aux[0,0]
            maux=sympy.eye(nf)
            maux[i,:]=maux[i,:]-q*maux[0,:]
            Aux=maux.multiply(Aux)
            m1=maux.multiply(m1)
            if Aux[i,0]!=0:
                maux=eye(nf)
                maux.row_swap(0,i)
                m1=maux.multiply(m1)
                Aux=maux.multiply(Aux)
        return m1
    
    def makeZeroInFirstRow(A,i):
        RT=makeZeroInFirstColumn(A.T,i)
        return RT.T
    
    def makeZeroFirstColumn(A):
        nf,nc=A.shape
        Aux=Matrix(A)
        R=Matrix.eye(nf)
        for i in range(1,nf):
            Raux=makeZeroInFirstColumn(Aux,i)
            Aux=Raux.multiply(Aux)
            R=Raux.multiply(R)
        return R
    
    def makeZeroFirstRow(A):
        B=Matrix(A.T)
        CT=makeZeroFirstColumn(B)
        return CT.T
    def makeZerosFirstRowColumn(A):
        Aux=Matrix(A)
        nf,nc=A.shape
        R1=eye(nf)
        C1=eye(nc)
        c0=Aux[1:,0]
        f0=Aux[0,1:]
        while(c0!=zeros(nf-1,1) or f0!=zeros(1,nc-1)):
            #print(c0,' - ',f0)
            #print(Aux)
            R=makeZeroFirstColumn(Aux)
            Aux=R.multiply(Aux)
            R1=R.multiply(R1)
            #print(Aux)
            C=makeZeroFirstRow(Aux)
            Aux=Aux.multiply(C)
            C1=C.multiply(C1)
            #print(Aux)
            #ee=input()
            #if not ee:
            #    break;
            c0=Aux[1:,0]
            f0=Aux[0,1:]
        return (R1,C1)

The function ``integerSmithNormalForm``

.. code:: python

    def integerSmithNormalForm(A):
        '''A=Matrix([[-3,11,3],[-48,15,12]])
        R,C=integerSmithNormalForm(A)
        [R.multiply(A).multiply(C),R.det(),C.det()]
        '''
        nf,nc=A.shape
        Aux=Matrix(A)
        R=eye(nf)
        C=eye(nc)
        if A==zeros(nf,nc):
            return (R,C)
        else:
            t=True
            while(t):
                R1,C1=putAbsMinInCorner(Aux)
                Aux=R1.multiply(Aux).multiply(C1)
                R=R1.multiply(R)
                C=C.multiply(C1)
                #print('abs in conrner:',Aux)
            
                R1,C1=makeZerosFirstRowColumn(Aux)
                Aux=R1.multiply(Aux).multiply(C1)
                R=R1.multiply(R)
                C=C.multiply(C1)
                #print('zeros in 1st RC:',Aux)
    
                R1=addRowIfNecesary(Aux)
                Aux=R1.multiply(Aux)
                R=R1.multiply(R)
                #print('add row if nec:',Aux)
                t= not (R1==eye(nf))
                
        Rm,Cm=integerSmithNormalForm(Aux[1:,1:])
        Raux=eye(nf)
        Caux=eye(nc)
        Raux[1:,1:]=Rm
        Caux[1:,1:]=Cm
        return (Raux.multiply(R),C.multiply(Caux))

Examples of how to use it

.. code:: python

    A=Matrix([[-3,11,3],[-48,15,12]])
    R,C=integerSmithNormalForm(A)
    [R.multiply(A).multiply(C),R.det(),C.det()]




.. math::

    \left [ \left[\begin{matrix}1 & 0 & 0\\0 & 3 & 0\end{matrix}\right], \quad -1, \quad 1\right ]



.. code:: python

    A=Matrix([[4],[16]])
    R,C=integerSmithNormalForm(A)
    [R.multiply(A).multiply(C),R.det(),C.det()]




.. math::

    \left [ \left[\begin{matrix}4\\0\end{matrix}\right], \quad 1, \quad 1\right ]



.. code:: python

    A=Matrix([[2,-1,1],[3,2,-1]])
    R,C=integerSmithNormalForm(A)
    [R.multiply(A).multiply(C),R.det(),C.det()]




.. math::

    \left [ \left[\begin{matrix}1 & 0 & 0\\0 & 1 & 0\end{matrix}\right], \quad -1, \quad 1\right ]



.. code:: python

    A=Matrix([[2,0,0],[0,1,-1]])
    R,C=integerSmithNormalForm(A)
    [R.multiply(A).multiply(C),R.det(),C.det()]




.. math::

    \left [ \left[\begin{matrix}1 & 0 & 0\\0 & 2 & 0\end{matrix}\right], \quad -1, \quad -1\right ]



.. code:: python

    A=Matrix([[4,1,-3],[1,-2,1]])
    R,C=integerSmithNormalForm(A)
    [R.multiply(A).multiply(C),R.det(),C.det()]




.. math::

    \left [ \left[\begin{matrix}1 & 0 & 0\\0 & 1 & 0\end{matrix}\right], \quad -1, \quad -1\right ]



.. code:: python

    A=Matrix([[1,-2,2,-1],[-3,1,1,1]])
    R,C=integerSmithNormalForm(A)
    [R.multiply(A).multiply(C),R.det(),C.det()]




.. math::

    \left [ \left[\begin{matrix}1 & 0 & 0 & 0\\0 & 1 & 0 & 0\end{matrix}\right], \quad -1, \quad 1\right ]



.. code:: python

    A=Matrix([[2,1,-2],[2,-1,1]])
    R,C=integerSmithNormalForm(A)
    [R.multiply(A).multiply(C),R.det(),C.det()]




.. math::

    \left [ \left[\begin{matrix}1 & 0 & 0\\0 & 1 & 0\end{matrix}\right], \quad -1, \quad 1\right ]



Aleatory examples

.. code:: python

    A=Matrix(randint(-50,50,(2,3))).applyfunc(int)
    R,C=integerSmithNormalForm(A)
    [R.multiply(A).multiply(C),R.det(),C.det()]




.. math::

    \left [ \left[\begin{matrix}1 & 0 & 0\\0 & 1 & 0\end{matrix}\right], \quad 1, \quad 1\right ]



.. code:: python

    A=Matrix([[-3,11,3],[-48,15,12]])
    R,C=integerSmithNormalForm(A)
    [R.multiply(A).multiply(C),R.det(),C.det()]




.. math::

    \left [ \left[\begin{matrix}1 & 0 & 0\\0 & 3 & 0\end{matrix}\right], \quad -1, \quad 1\right ]



.. code:: python

    for x in range(10):
        sh=tuple(map(int,randint(1,7,(1,2))[0]))
        A=randint(-100,100,sh)
        l=[list(x) for x in A]
        A=Matrix(l).applyfunc(int)
        #pprint(A)
        #pprint((A,Matrix(sh).T.applyfunc(int)))
        R,C=integerSmithNormalForm(A)
        D=R.multiply(A).multiply(C)
        #pprint([D,R.det(),C.det(),isSeqDiagOfDivisible(D)])
        #print(isDiagonal(D))
        #print(isSeqDiagOfDivisible(D))
        if not isSeqDiagOfDivisible(D):
            print(A)

.. code:: python

    A=Matrix([[-31, -96, -63, 81], [32, -31, -5, 33], [9, 70, 48, 57], [85, 61, -67, 86]])
    print(A)
    R,C=integerSmithNormalForm(A)
    [R.multiply(A).multiply(C),R.det(),C.det()]


.. parsed-literal::

    Matrix([[-31, -96, -63, 81], [32, -31, -5, 33], [9, 70, 48, 57], [85, 61, -67, 86]])




.. math::

    \left [ \left[\begin{matrix}1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\0 & 0 & 1 & 0\\0 & 0 & 0 & 66029594\end{matrix}\right], \quad -1, \quad -1\right ]



Function to compute the generators of a subgroup of :math:`\mathbb Z^p` from its defining equations
---------------------------------------------------------------------------------------------------

Function to obtain a minimal system of generators from a set of homogeneus equations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    def equationsToGeneratorsHomogeneusCase(A):
        '''equationsToGeneratorsHomogeneusCase(Matrix([[5,-7,3,-2],[6,9,-10,1]]))
        '''
        nf,nc=A.shape
        R,C=integerSmithNormalForm(A)
        D=R.multiply(A).multiply(C)
        noNullOfD=[D[i,i] for i in range(min(D.shape)) if D[i,i]!=0]
        r=len(noNullOfD)
        nGen=nc-r
        Caux=C[:,-nGen:].T
        return Caux
        #return [Caux[i,:] for i in range(Caux.shape[0])]

.. code:: python

    A=Matrix([[5,7,-3,-2],[1,2,3,4]])
    print(A)
    sG=equationsToGeneratorsHomogeneusCase(A)
    pprint(sG)


.. parsed-literal::

    Matrix([[5, 7, -3, -2], [1, 2, 3, 4]])
    ⎡ 9   -6  1  0 ⎤
    ⎢              ⎥
    ⎣-32  22  0  -3⎦


.. code:: python

    A.multiply(sG.T)




.. math::

    \left[\begin{matrix}0 & 0\\0 & 0\end{matrix}\right]



Function to obtain the minimal system from a set of equations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    def equationsToGenerators(A,modulus):
        '''A=Matrix([[1,-2,3,4],[6,8,-10,-16],[5,7,-9,2]])
        mm=Matrix([2,3])
        sG=equationsToGenerators(A,mm)
        pprint(sG)
        A.multiply(sG.T)
        '''
        Aux=Matrix(A)
        nfm,ncm=modulus.shape
        nf,nc=A.shape
        idaux=eye(nfm)
        for i in range(nfm):
            idaux[i,i]=-modulus[i]
        zaux=zeros(nf-nfm,nfm)
        idaux=idaux.col_join(zaux)
        Aux=Aux.row_join(idaux)
        #pprint(Aux)
        r=equationsToGeneratorsHomogeneusCase(Aux)
        #pprint(Aux.multiply(r.T))
        return r[:,0:nc]

.. code:: python

    A=Matrix([[1,-2,3,4],[6,8,-10,-16],[5,7,-9,2]])
    pprint(A)
    mm=Matrix([2,3])
    sG=equationsToGenerators(A,mm)
    pprint(sG)
    A.multiply(sG.T)


.. parsed-literal::

    ⎡1  -2   3    4 ⎤
    ⎢               ⎥
    ⎢6  8   -10  -16⎥
    ⎢               ⎥
    ⎣5  7   -9    2 ⎦
    ⎡  21    0     9      -12 ⎤
    ⎢                         ⎥
    ⎢ -241   0    -103    139 ⎥
    ⎢                         ⎥
    ⎣-36924  -2  -15782  21298⎦




.. math::

    \left[\begin{matrix}0 & 6 & 926\\228 & -2640 & -404508\\0 & 0 & 0\end{matrix}\right]



Function to compute aminimal system of generators from asystem of generators
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    def minimalSystemOfGenerators(sGen):
        '''Returns a minimal system of generators of the subgroup generated by 
        the rows of the sympy.matrix sGen.
        >>> minimalSystemOfGenerators(Matrix([[5,1,0],[1,2,-3],[6,3,-3]]))
        '''
        A=Matrix(sGen)
        R,C=integerSmithNormalForm(A)
        D=R.multiply(A).multiply(C)
        RA=R.multiply(A)
        noNullOfD=[D[i,i] for i in range(min(D.shape)) if D[i,i]!=0]
        r=len(noNullOfD)
        return RA[0:r,:]

.. code:: python

    minimalSystemOfGenerators(Matrix([[5,1,0],[1,2,-3],[6,3,-3]]))




.. math::

    \left[\begin{matrix}5 & 1 & 0\\9 & 0 & 3\end{matrix}\right]



Function to compute the equations from a system of generators
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    def generatorsToEquations(sGen,lVars=None):
        '''sGen=Matrix([[2,-4,8],[3,2,-1]])
        s1=generatorsToEquations(sGen,[x,y,z])
        s2=generatorsToEquations(sGen)
        [s1,s2]
        '''
        A=Matrix(sGen)
        nf,nc=A.shape
        R,C=integerSmithNormalForm(A)
        D=R.multiply(A).multiply(C)
        noNullOfD=[D[i,i] for i in range(min(D.shape)) if D[i,i]!=0]
        lmod=noNullOfD+[0 for i in range(nc-len(noNullOfD))]
        n1=len([x for x in noNullOfD if x==1])
        lmod=lmod[n1:]
        if not lVars:
            return (C.T[n1:,:],Matrix(lmod))
        else:
            return (Matrix(lVars).T.multiply(C[:,n1:]).T,Matrix(lmod))

.. code:: python

    sGen=Matrix([[2,-4,8],[3,2,-1]])
    x,y,z=sympy.symbols('x y z')
    s1=generatorsToEquations(sGen,[x,y,z])
    s2=generatorsToEquations(sGen)
    [s1,s2]




.. math::

    \left [ \left ( \left[\begin{matrix}x - 2 y - z\\- 6 x + 13 y + 8 z\end{matrix}\right], \quad \left[\begin{matrix}2\\0\end{matrix}\right]\right ), \quad \left ( \left[\begin{matrix}1 & -2 & -1\\-6 & 13 & 8\end{matrix}\right], \quad \left[\begin{matrix}2\\0\end{matrix}\right]\right )\right ]



.. code:: python

    A=Matrix([[2,-1,1],[3,2,-1]])
    R,C=integerSmithNormalForm(A)
    [R,R.multiply(A).multiply(C),C]




.. math::

    \left [ \left[\begin{matrix}-1 & 0\\2 & 1\end{matrix}\right], \quad \left[\begin{matrix}1 & 0 & 0\\0 & 1 & 0\end{matrix}\right], \quad \left[\begin{matrix}0 & 0 & 1\\1 & 1 & -5\\0 & 1 & -7\end{matrix}\right]\right ]



--------------

.. code:: python

    x1,x2,x3,x4,x5,x6=sympy.symbols('x1 x2 x3 x4 x5 x6')

:math:`\widetilde H=\mathbf N^4/\sim_M` with
$M=:raw-latex:`\langle `(-5,3,2,10),(-2,1,4,15),(-5,3,2,0)
:raw-latex:`\rangle `$

.. code:: python

    genM=Matrix([[-5,-7,5,7],[12,1,-1,-12],[-5,0,0,5]])
    generatorsToEquations(genM,[x1,x2,x3,x4])




.. math::

    \left ( \left[\begin{matrix}- 2 x_{1} - 55 x_{2} - 79 x_{3}\\x_{1} + x_{2} + x_{3} + x_{4}\end{matrix}\right], \quad \left[\begin{matrix}10\\0\end{matrix}\right]\right )



:math:`\widetilde H \cong \langle (8,1),(5,1),(1,1),(0,1)\rangle \leq \mathbf Z_{10}\times \mathbf Z`

Examples of *On divisor-closed submonoids and minimal distances in finitely generated monoids*
==============================================================================================

Example 24
----------

.. code:: python

    genM=Matrix([[-5,-7,5,7],[12,1,-1,-12],[-5,0,0,5]])
    generatorsToEquations(genM,[x1,x2,x3,x4])




.. math::

    \left ( \left[\begin{matrix}- 2 x_{1} - 55 x_{2} - 79 x_{3}\\x_{1} + x_{2} + x_{3} + x_{4}\end{matrix}\right], \quad \left[\begin{matrix}10\\0\end{matrix}\right]\right )



Example 25
----------

.. code:: python

    genM=Matrix([[-4,-2,4,4],[5,2,-5,-4],[2,2,-2,-4]])
    generatorsToEquations(genM,[x1,x2,x3,x4])




.. math::

    \left ( \left[\begin{matrix}- 2 x_{1} + 5 x_{2}\\x_{1} + x_{3}\\2 x_{2} + x_{4}\end{matrix}\right], \quad \left[\begin{matrix}2\\0\\0\end{matrix}\right]\right )



:math:`\Delta(H)` is in this case equal to

.. code:: python

    aux=numpy.abs(numpy.sum(numpy.array([list(genM[i,:]) for i in range(genM.shape[0])]),axis=1))
    aux,numpy.min(aux)




.. parsed-literal::

    (array([2, 2, 2], dtype=object), 2)



.. code:: python

    AejFin=Matrix([[1,0],[2,1]])
    pprint(AejFin)
    mmEjemploFin=Matrix([2])
    sGejemploFin=equationsToGenerators(AejFin,mmEjemploFin)
    pprint(sGejemploFin)
    AejFin.multiply(sGejemploFin.T)


.. parsed-literal::

    ⎡1  0⎤
    ⎢    ⎥
    ⎣2  1⎦
    [2  -4]




.. math::

    \left[\begin{matrix}2\\0\end{matrix}\right]



Example 30
----------

We compute a system of generators of the group associated to :math:`H`
and :math:`\min(\Delta(H))`

.. code:: python

    m=equationsToGeneratorsHomogeneusCase(Matrix([[5,10,15,0,10],[9,11,5,0,0],[0,0,0,1,1]]))
    pprint(m)
    l=np.sum(sympyMatrix2numpyArray(m),axis=1)
    pprint(l)
    md=gcdL(l)


.. parsed-literal::

    ⎡-2   18   -36   -37   37 ⎤
    ⎢                         ⎥
    ⎣-23  202  -403  -414  414⎦
    [ -20 -224]


:math:`\min(\Delta(H))` is equal to {{md}}

We compute now :math:`\min(\Delta(S_6))`

.. code:: python

    m=equationsToGeneratorsHomogeneusCase(Matrix([[5,10,15],[9,11,5],[0,0,0]]))
    pprint(m)
    l=np.sum(sympyMatrix2numpyArray(m),axis=1)
    print(l)
    md=gcdL(l)


.. parsed-literal::

    [-23  22  -7]
    [-8]


:math:`\min(\Delta(S_6))` is equal to {{np.abs(md)}}

Example 31
----------

Group associated to :math:`\pi(S_{22})`

.. code:: python

    equationsToGenerators(Matrix([[1,0],[2,1]]),Matrix([2]))




.. math::

    \left[\begin{matrix}2 & -4\end{matrix}\right]


